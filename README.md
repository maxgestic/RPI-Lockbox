# RPI-Lockbox
My project will be creating a lock box using a raspberry pi zero, a capacitive fingerprint scanner and an electromagnetic solenoid lock. The raspberry pi will be connected to an EC2 instance in AWS that will allow the user to control the lockbox even if they are not on the same network, they will be able to start the fingerprint registration process, delete fingerprints or turn off the fingerprint on the box remotely. These commands get sent to the raspberry pi via a client server model using sockets implemented in C. All of the communication between the raspberry pi and the capacitive fingerprint scanner will be doe via a C program that will use the raspberry piâ€™s serial pins to send a receive data from the fingerprint scanner. The lock is handled via a Linux kernel module and is connected to the pi via a 5V single channel relay module due to the lock requiring a higher current than the raspberry pi can provide. When the fingerprint scanner C program detects a valid fingerprint it will send the command to the LKM to unlock the solenoid and after a certain timeout the lock will close again. All of these components will be in a box and the box will have a single cable that connects to a wall plug, if there is enough time I could experiment with adding battery power as an alternative to being plugged into the wall. The EC2 instance will also host a web application that lets the user do the functions mentioned above with a nice interface. The way the web application will talk to the C application server that communicates with the raspberry pi client is by saving instructions in specific files that are constantly checked by the server C program for updates. If the server detects that a file has been altered then it will read the instruction from the file and send the client the corresponding instructions. The reason this will be done with files is to allow maximum compatibility between the web application and the C based server. Most programming languages can write and read system files and therefore this was the best solution I could think of for the web application to interact with an already running C program. The server also has a security mechanism built in that it will disconnect any client that does not send the correct data during the connection process. This is to prevent any malicious clients from connecting to the server.
